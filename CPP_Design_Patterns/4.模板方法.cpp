/*模板方法：就是由之前的由用户来组织主流程，lib库来完成算法的流程模式修改为
    用户只负责算法的实现，主流程在lib库中；库通过运行时动态绑定来调用用户实现的方法
    通过虚函数实现
*/
/*
是一种抽象类的应用

在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。
但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。
*/

/*
    该模式的主要优点如下。
        它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
        它在父类中提取了公共的部分代码，便于代码复用。
        部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。

    该模式的主要缺点如下。
        对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。
        父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。
        由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。
*/

/*
    在父类中定义一些钩子方法，在子类中实现，可以改变父类的运行结果
*/
//程序库开发人员
class Library{
public:
	//稳定 template method
    void Run(){
        
        Step1();

        if (Step2()) { //支持变化 ==> 虚函数的多态调用
            Step3(); 
        }

        for (int i = 0; i < 4; i++){
            Step4(); //支持变化 ==> 虚函数的多态调用
        }

        Step5();

    }
	virtual ~Library(){ }

protected:
	
	void Step1() { //稳定
        //.....
    }
	void Step3() {//稳定
        //.....
    }
	void Step5() { //稳定
		//.....
	}

	virtual bool Step2() = 0;//变化
    virtual void Step4() =0; //变化
};