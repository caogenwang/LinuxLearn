1. = 和 := 的区别
    =用来给已经声明的变量赋值，:=是同时声明和赋值；已经声明的变量不能再用 :=来赋值
2. 指针的作用
    获取存放变量的地址
3. Go 允许多个返回值吗？
    允许返回
4. Go有异常类型吗？
    error类型，错误处理
5. 什么是协程（Goroutine）
    在用户空间实现的一种轻量级线程，不需要内核的切换
6. 如何高效地拼接字符串
    拼接字符串有四种方法:1.sprintf
    2. + 
    3. builder 
    4. buf bytes.Buffer
7. 什么是 rune 类型
    是一个int32类型，可以得到字符串的长度，而不是字符串在底层字节数组的长度
8. 如何判断 map 中是否包含某个 key ？
    通过赋值给一个参数，查看返回的值是否为true
9.Go支持默认参数或可选参数吗？
    我们知道，Go中的函数是不支持带默认值的可选参数的。
    这是Go语言的设计者为了保证代码可读性特意抛弃的功能。
    我们可以利用变长参数个数函数这一特性来（不是十分完美地）模拟默认参数
10.defer 的执行顺序
    defer 执行顺序类似栈的先入后出原则（FILO）
11。如何交换 2 个变量的值？

12.Go 语言 tag 的用处？
    我们可以通过Tag来增强结构体的定义，Tag会带上一些meta信息。最常用的是在
    json中
13. 如何判断 2 个字符串切片（slice) 是相等的？
    DeepEqual和循环遍历
14. 字符串打印时，%v 和 %+v 的区别
    %v	值的默认格式表示
    %+v	类似%v，但输出结构体时会添加字段名
15.Go 语言中如何表示枚举值(enums)
    通过const和iota进行定义
16.空 struct{} 的用途
    总结
    空结构体的特点
    不占用内存
    地址不变
    空结构体作用
    建议用于传递信号的通道，因为不占用内存

1.init() 函数是什么时候执行的？
    包被加载的时候
2. Go语言的局部变量分配在栈上还是堆上?
    看来确实是go语言会根据局部变量有没有发生逃逸行为来自动决定一个局部变量是分配在栈，还是分配在堆。
    对于动态new出来的局部变量，go语言编译器也会根据是否有逃逸行为来决定是分配在堆还是栈，而不是直接分配在堆中。
3. 2 个 interface 可以比较吗 ？
    如果两个interface 的 方法相同，那么结果为 true
    如果方法不同，为false。
    如果一个含有方法的interface 实例 和一个 空的interface 实例 比较，并且该实例 未 赋值，那么两者相等。
    但是，如果对空的interface 实例赋值，那么不相等
4. 2 个 nil 可能不相等吗？
    nil是没有默认类型的，它的类型具有不确定性，我们在使用它时必须要提供足够的信息能够让编译器推断nil期望的类型
    通过编译结果我们可以看出==符号对于nil来说是一种未定义的操作，所以是不可以比较两个nil的
    从运行结果我们可以看出，指针类型nil、channel类型的nil、interface类型可以相互比较，而func类型、map类型、slice类型只能与nil标识符比较，两个类型相互比较是不合法的。
5.简述 Go 语言GC(垃圾回收)的工作原理

6. 函数返回局部变量的指针是否安全？
    go的方法可以直接返回局部变量的指针，这主要依赖go是有runtime的语言，编译器在发现有变量可以逃逸出去的时候会在
    堆上分配变量而不是栈上，这样就可以返回该变量的指针了，且会使该地址的引用+1，当生命空间结束时，gc会去回收。
    也就是可以使安全的
7. 非接口的任意类型T() 都能够调用 *T 的方法吗？反过来呢？
    无缓冲的与有缓冲channel有着重大差别
    那就是一个是同步的 一个是非同步的

8. 什么是协程泄露(Goroutine Leak)？
    goroutine leak，是go协程泄漏，什么是go协程泄漏，通俗来说，开启了一个goroutine，用完后，
    我们要正确让其结束。如果它没用了，还没结束，那就是goroutine leak.

9. Go 可以限制运行时操作系统线程的数量吗？
    Go 限制同时执行的线程数
    
    问题
    假设，现在有1w个任务，需要通过线程并发执行。如果直接执行，会把内存撑爆。需要让这些任务一批一批执行。如果设定，每次最多同时执行10个任务。
    
    方案
    需要用到通道channel，利用channel的limit，通过堵塞通道的方式，把进程堵住。
    ch := make(chan struct{}, 10)
    for i:=0; i<10000; i++{
        n := i
        fmt.Println("轮到",n )
        ch <- struct{}{}
        go func() {
            time.Sleep(10 * time.Second)
            fmt.Println("结束",n )
            <-ch
              // 结束释放一个通道
        }()
    }

链接：https://www.jianshu.com/p/b9ae6d2b4e04





10. make与new的区别
    Make 用于map、slice 和channel几种类型的内存分配。并且返回一个有初始值的对象，注意不是指针。
    注：channel在make之后打印出来的也是内存地址，是个特殊类型。
    New 用于使用type声明的类型的内存分配。new(T)分配了零值填充的T类型的内存空间，并且返回其地址，
    即一个T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：new返回指针。

11. slice和array的区别
    https://www.jb51.net/article/181336.htm
    1.数组是一种具有固定长度的基本数据结构；slice是可以增长的，按照2的指数增长
    在golang中有数组和Slice两种数据结构，Slice是基于数组的实现，是长度动态不固定的数据结构，
    本质上是一个对数组字序列的引用，提供了对数组的轻量级访问
    2.数组作为参数时是值传递，因为切片是个引用类型,所以它作为参数传递给函数,函数操作的实质是底层数组


12.简要描述go中的main和init函数的区别
    首先，这两个函数应用位置不同，init函数可以应用于所有的package，main只能应用于 package main，
        需要注意的是虽然一个package中可以写任意多个init,但是无论是从可读性还是可维护性来说，都是不推荐的； 
    其次，这两个函数定义时都不能有任何的参数和返回值， 
    最后，个人理解，init函数为初始化操作，main函数为程序入口。