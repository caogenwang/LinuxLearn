1. = 和 := 的区别
    =用来给已经声明的变量赋值，:=是同时声明和赋值；已经声明的变量不能再用 :=来赋值
2. 指针的作用
    获取存放变量的地址
3. Go 允许多个返回值吗？
    允许返回
4. Go有异常类型吗？
    error类型，错误处理
5. 什么是协程（Goroutine）
    在用户空间实现的一种轻量级线程，不需要内核的切换
6. 如何高效地拼接字符串
    拼接字符串有四种方法:1.sprintf
    2. + 
    3. builder 
    4. buf bytes.Buffer
7. 什么是 rune 类型
    是一个int32类型，可以得到字符串的长度，而不是字符串在底层字节数组的长度
8. 如何判断 map 中是否包含某个 key ？
    通过赋值给一个参数，查看返回的值是否为true
9.Go支持默认参数或可选参数吗？
    我们知道，Go中的函数是不支持带默认值的可选参数的。
    这是Go语言的设计者为了保证代码可读性特意抛弃的功能。
    我们可以利用变长参数个数函数这一特性来（不是十分完美地）模拟默认参数
10.defer 的执行顺序
    defer 执行顺序类似栈的先入后出原则（FILO）
11。如何交换 2 个变量的值？

12.Go 语言 tag 的用处？
    我们可以通过Tag来增强结构体的定义，Tag会带上一些meta信息。最常用的是在
    json中
13. 如何判断 2 个字符串切片（slice) 是相等的？
    DeepEqual和循环遍历
14. 字符串打印时，%v 和 %+v 的区别
    %v	值的默认格式表示
    %+v	类似%v，但输出结构体时会添加字段名
15.Go 语言中如何表示枚举值(enums)
    通过const和iota进行定义
16.空 struct{} 的用途
    总结
    空结构体的特点
    不占用内存
    地址不变
    空结构体作用
    建议用于传递信号的通道，因为不占用内存

1.init() 函数是什么时候执行的？
    包被加载的时候
2. Go语言的局部变量分配在栈上还是堆上?
    看来确实是go语言会根据局部变量有没有发生逃逸行为来自动决定一个局部变量是分配在栈，还是分配在堆。
    对于动态new出来的局部变量，go语言编译器也会根据是否有逃逸行为来决定是分配在堆还是栈，而不是直接分配在堆中。
3. 2 个 interface 可以比较吗 ？
    如果两个interface 的 方法相同，那么结果为 true
    如果方法不同，为false。
    如果一个含有方法的interface 实例 和一个 空的interface 实例 比较，并且该实例 未 赋值，那么两者相等。
    但是，如果对空的interface 实例赋值，那么不相等
4. 2 个 nil 可能不相等吗？
    nil是没有默认类型的，它的类型具有不确定性，我们在使用它时必须要提供足够的信息能够让编译器推断nil期望的类型
    通过编译结果我们可以看出==符号对于nil来说是一种未定义的操作，所以是不可以比较两个nil的
    从运行结果我们可以看出，指针类型nil、channel类型的nil、interface类型可以相互比较，而func类型、map类型、slice类型只能与nil标识符比较，两个类型相互比较是不合法的。
5.简述 Go 语言GC(垃圾回收)的工作原理

6. 函数返回局部变量的指针是否安全？
    go的方法可以直接返回局部变量的指针，这主要依赖go是有runtime的语言，编译器在发现有变量可以逃逸出去的时候会在
    堆上分配变量而不是栈上，这样就可以返回该变量的指针了，且会使该地址的引用+1，当生命空间结束时，gc会去回收。
    也就是可以使安全的
7. 非接口的任意类型T() 都能够调用 *T 的方法吗？反过来呢？
    无缓冲的与有缓冲channel有着重大差别
    那就是一个是同步的 一个是非同步的

8. 什么是协程泄露(Goroutine Leak)？
    goroutine leak，是go协程泄漏，什么是go协程泄漏，通俗来说，开启了一个goroutine，用完后，
    我们要正确让其结束。如果它没用了，还没结束，那就是goroutine leak.

9. Go 可以限制运行时操作系统线程的数量吗？
    Go 限制同时执行的线程数
    
    问题
    假设，现在有1w个任务，需要通过线程并发执行。如果直接执行，会把内存撑爆。需要让这些任务一批一批执行。如果设定，每次最多同时执行10个任务。
    
    方案
    需要用到通道channel，利用channel的limit，通过堵塞通道的方式，把进程堵住。
    ch := make(chan struct{}, 10)
    for i:=0; i<10000; i++{
        n := i
        fmt.Println("轮到",n )
        ch <- struct{}{}
        go func() {
            time.Sleep(10 * time.Second)
            fmt.Println("结束",n )
            <-ch
              // 结束释放一个通道
        }()
    }

链接：https://www.jianshu.com/p/b9ae6d2b4e04





10. make与new的区别
    Make 用于map、slice 和channel几种类型的内存分配。并且返回一个有初始值的对象，注意不是指针。
    注：channel在make之后打印出来的也是内存地址，是个特殊类型。
    New 用于使用type声明的类型的内存分配。new(T)分配了零值填充的T类型的内存空间，并且返回其地址，
    即一个T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：new返回指针。

11. slice和array的区别
    https://www.jb51.net/article/181336.htm
    1.数组是一种具有固定长度的基本数据结构；slice是可以增长的，按照2的指数增长
    在golang中有数组和Slice两种数据结构，Slice是基于数组的实现，是长度动态不固定的数据结构，
    本质上是一个对数组字序列的引用，提供了对数组的轻量级访问
    2.数组作为参数时是值传递，因为切片是个引用类型,所以它作为参数传递给函数,函数操作的实质是底层数组


12.简要描述go中的main和init函数的区别
    首先，这两个函数应用位置不同，init函数可以应用于所有的package，main只能应用于 package main，
        需要注意的是虽然一个package中可以写任意多个init,但是无论是从可读性还是可维护性来说，都是不推荐的； 
    其次，这两个函数定义时都不能有任何的参数和返回值， 
    最后，个人理解，init函数为初始化操作，main函数为程序入口。

    13. 程序输出
    func main(){
        /*
        先defer的后执行
        recover后输出panic中的信息
        */
        defer func(){
            If err:=recover();err!=nil{
                fmt.Print(err)
            } else {
                fmt.Print("no")
            }
        }()
        defer func(){
            panic("1111111111111")
        }()
        panic("22222222222")
    }
    答案：不会报错，而是被recover捕捉，打印出1111111111111

13.代码的输出？
    var c1=make(chan int)
    var c2=make(chan int)
    func main(){
        go func(){
            fmt.Println("111111")
            c1 <-<- c2//读取c2的元素放入到c1
        }()
        go func(){
            c1 <-<- c2
            fmt.Println("222222")
        }()
        <- c1
    }
    两个协程都是读取c2中的元素，然后塞入c1, 然而c2又是无缓冲且没有任何协程在往c2中写数据，
    所以第一个协程读c2的时候就导致死锁，因为c2永远读不出数据。 如何改能让程序不报错？在第一个协程前加一个协程：

    gofunc(){ 
        c2<-1 
    }()

14.简述channel和mutex锁机制的原理异同与使用场景
    channel原理: 当channel能存放的元素数量为0时表示为阻塞型channel。
                当管道无数据时，需要从管道取数据的协程会被阻塞，不会向下执行。 
                所以可以通过多个协程应用同一个channel，从而实现协程间的同步。
                channel使用场景： 1. 需要协程通信时     2. 需要管道传输数据时。
    Mutex原理：互斥锁用来防止资源竞争，多个协程使用同一把排它锁时，原来是并发运行的话将变为
              线性运行。

              排它锁针对任意操作都是排它的，没有读写区分。 若一个goroutine获得锁，则其他goroutine会一直阻塞到他释放锁后才能获得锁。

mutex使用场景： 解决协程并发时对同一资源的竞争问题

15. sync.WaitGroup的使用场景？
    程序中需要并发，需要创建多个goroutine，并且一定要等这些并发全部完成后才继续接下来的程序执行．
    WaitGroup的特点是Wait()可以用来阻塞直到队列中的所有任务都完成时才解除阻塞，而不需要sleep一个固定的时间来等待．
    但是其缺点是无法指定固定的goroutine数目（也就是协程池功能)

16. 写一段闭包代码，阐述其作用
    package main
    import "fmt"
    type logClosure func(format string,v...interface{})

    func LoggerWrapper(logType string)logClosure{
        return func(format string,v...interface{}){//返回一个打印的函数，打印log
            fmt.Println(fmt.Sprintf("[%s] %s",logType,format),v...,)
            fmt.Println()
        }
    }
    func main(){
        info_logger := LoggerWrapper("INFO")
        waring_logger := LoggerWrapper("WARNING")
        info_logger("this is a %s log","info")
        waring_logger("this is a %s log","waring")
    }

17. 执行这段代码会发生什么？
        type ConfigOne struct {
	        Daemon string
        }
        
        func (c *ConfigOne) String() string {
            return fmt.Sprintf("print: %v", c)
        }
        c := &ConfigOne{}
        _ = c.String()

18.单例实现
    var once sync.Once

    type manager struct{
        name string
    }

    var single *manager

    func Singleton() *manager{
        once.Do(func(){
            single = &manager{"a"}
        })
        return single
    }
    注意一个once实例只能用一次。

19. 这段代码输出什么？
    fmt.Println(len("你好bj!")) 
    答案：是9， len方法返回字符串的字节长度

20.这段代码可以编译过吗，如果会错是在哪一行？
    type Test struct{
        Name string
    }

    var list map[string]Test

    func main(){
        list = make(map[string]Test)
        name := Test{"xiaoming"}
        list["name"] = name

        fmt.Println(list["name"].Name)
        list["name"].Name = "Hello"
        fmt.Println(list["name"])
    }
    不能！倒数第三行报错： cannot assign to struct field list["name"].Name in map
    因为map的value不是指针。首先，map本来存储的就是value的“初始指针值”，可以打印list["name"].Name,
    但不能通过取值的方式来修改。 因为当map扩容时，内部元素会在内存中移动， 移动之后list["name"].Name
    获取到的值依然有效，但获取到的指针是无效的，如果允许这样赋值，那之后再打印list["name"].Name 
    是获取不到修改后的值的。 而当value是指针时，也就是说list["name"]是指针，list["name"].Name
    就是指针内部的指针，值改变后，list["name"]仍然获取到的是原始数据指针，也就仍然可以获取到
    list["name"].Name。
21. 

