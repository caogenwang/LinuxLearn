1. 各种排序的思想
    1. 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，
        其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
        实际上交换排序，选择一个基准，比基准小的放在前边，基准大的放在后边。然后再继续递归，继续排序。

        实现思路:从数列中挑出一个元素，称为 “基准”（pivot）；重新排序数列，所有元素比基准值小的摆放在基准前面，
                所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。
                这个称为分区（partition）操作；递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
        代码实现：
            int partition(int *arr,int left,int right){//得到基准值
                int p = arr[left];
                int i = left + 1;
                int j = right;
                while (true){
                    while(i <= j && arr[i] <= p)//找到第一个比基准值大的
                        i ++;
                    while(i <= j && arr[j] >= p)//找到第一个比基准值小的
                        j --;
                    if(i >= j)
                        break;
                    //交换两个元素的位置，使得左边的元素不大于pivot,右边的不小于pivot
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                arr[left] = arr[i];
                arr[i] = p;
                return i;
            }
            void quick(int *arr,int left,int right){
                int mid = partition(arr,left,right);
                arr = quick(arr,left,mid-1);
                arr = quick(arr,mid+1,right);
            }
            int main(){
                int arr[10] = {2,9,5,6,4,8,7,3,1,0};
                arr = quick(arr,0,9);
                display(arr);
            }
            时间复杂度分析:什么时候是O(n^2):
                         什么时候是O(nlogn):
        2. 插入排序（Insertion Sort）:算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，
                                    于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入.在未排序的
                                    数列中选择元素插入已经排序的序列，依次向前扫描。
            算法设计：
                    1. 从第一个元素开始，该元素可以认为已经被排序；
                    2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
                    3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
                    4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
                    5. 将新元素插入到该位置后；
                    6. 重复步骤2~5。

                insert_sort(int*arr)
                {
                    for(int i = 0;i<arr.length - 1;i++)
                    {
                        int j = i;
                        int temp = arr[i + 1];
                        while(j>0 && temp<arr[j]){
                            arr[j] = a[j - 1];
                            j --;
                        }
                        arr[j] = temp;
                    }
                    return arr;
                }
        3. 希尔排序，第一个突破O(n^2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，
                它会优先比较距离较远的元素。希尔排序又叫缩小增量排序.是一种间隔排序。
                希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。
                动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的
                算法设计：
                int shell_sort(vector<int> arr){
                    int gap = arr.size();
                    while(gap > 0){
                        for (int i = 0; i < gap; i++)
                        {   
                            group_sort(array,i,gap);//分组排序
                        }
                        gap = gap/2;
                    }
                }
                void group_sort(vector<int>arr,int i,int gap){
                    for(int j = i + gap;j < arr.size() - gap;j +=gap)
                    {
                        int tmp = a[j];
                        int k = j - gap;//这一段是插入排序
                        while(k > 0 && tmp < arr[k]){
                            a[k + gap] = a[k];
                            k -= gap;
                        }
                        a[k + gap] = tmp;
                    }
                }
            4. 选择排序：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，
                        然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，
                        直到所有元素均排序完毕
                        算法的设计:
                        初始状态：无序区为R[1..n]，有序区为空；
                        第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
                        n-1趟结束，数组有序化了。

                        choose_sort(int test){
                            for (int i = 0; i < 10; i++)
                            {
                                int min = i;
                                for (int j = i+1; j < 10; j++)
                                {
                                    if (test[j] < test[min])//一直都在找一个最小的，然后在交换
                                    {
                                        min = j;
                                    }
                                }
                                int temp = test[i];
                                test[i] = test[min];
                                test[min] = temp;
                            }
                        }
                5、归并排序（Merge Sort）该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
                    将已有序的子序列合并，得到完全有序的序列；
                    即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并
                    算法设计：
                        1. 把长度为n的输入序列分成两个长度为n/2的子序列；
                        2. 对这两个子序列分别采用归并排序；
                        3. 将两个排序好的子序列合并成一个最终的排序序列。
                    
                merge_sort(vector<int> arr,int left,int right){
                    if(left < right){
                        int mid = (left + right) / 2;
                        arr1 = merge_sort(arr,left,mid);
                        arr2 = merge_sort(arr,mid+1,right);
                        merge(arr1,arr2)
                    }
                }
                vector<int> merge(vector<int>&v1,vector<int>&v2)
                {
                    int len = max(v1.size(),v2.size());
                    vector<int> v3(len,0);
                    int i = 0;
                    int j = 0;
                    int m = 0;
                    while(i < v1.size() && j < v2.size()){
                        if(arr[i] > arr[j])
                            v3[m++] = i++;
                        else
                            v3[m++] = j++;
                    }
                    while(i < v1.size())
                        v3[m++] = i++;
                    while(j < v2.size())
                         v3[m++] = j++;

                    return v3;
                }

                6. 堆排序:指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：
                    即子结点的键值或索引总是小于（或者大于）它的父节点.
                    算法设计：
                            1).将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
                            2).将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
                            3).由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，
                                然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。
                                不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。
                    heap_sort(int arr[10],int length){
                        int arr[10] = {{2,9,5,6,4,8,7,3,1,0}};
                        //在一个数组中的父子关系，父是n，则子是2*n+1，和2*n+2
                        //构建大顶堆
                        for (int i = ((length - 1) -1)/2; i >=0; i--)
                        {
                            downAdjust(a,i,length - 1);
                        }
                        for(int i = length - 1;i >= 1;i--){
                            int tmp = a[i];
                            a[i] = a[0];
                            a[0] = tmp;
                            downAdjust(a,0,i - 1);
                        }
                    }
                    void downAdjust(int arr,int parent,int range)
                    {
                        int tmp = arr[parent];
                        int child = 2 * parent + 1;
                        while(child <= n){
                            if(child + 1 <= n && a[child] < a[child + 1])
                                child ++;
                            if(tmp > child)
                                break;
                            arr[parent] = arr[child]
                            parent = child;
                            child = 2*parent + 1;
                        }
                        arr[parent] = tmp;
                    }
                7. 冒泡排序
                8. 计数排序:其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 
                    作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数.
2. 分布式唯一id的生成方法
    1. 数据库自增长序列或字段
    2. UUID
    3. Redis生成ID
            可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。
            可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5
    4. Twitter的snowflake算法
    5. 利用zookeeper生成唯一ID
    6. MongoDB的ObjectId

5. define和const区别
    (1) 编译器处理方式不同
    　　define宏是在预处理阶段展开。
    　　const常量是编译运行阶段使用。
    (2) 类型和安全检查不同
    　　define宏没有类型，不做任何类型检查，仅仅是展开。
    　　const常量有具体的类型，在编译阶段会执行类型检查。
    (3) 存储方式不同
    　　define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（是立即数，使用一次分配一次）
    　　const常量会在内存中分配(可以是堆中也可以是栈中)。（第一次使用时才分配，之后不再分配）
    (4)const  可以节省空间，避免不必要的内存分配。
   
    const 比 #define有哪些优点：
    两者都可以用来定义常量，分别是const常量和宏常量
    （1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。
        而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。
    （2）可以对const常量进行调试，但是不能对宏常量进行调试。
    （3）const常量更有效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，
        这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。
6. 为什么用const引用
        （1）&是为了引用传递，防止值传递的复制数据，const是为了保护数据不被改动。
            const&防止传值时拷贝构造函数的调用开销
        （2）形参的对象为顶层const时，传入的实参既可以是const值，又可以是非const值，若是底层const，传入的实参只能是const的值。
            顶层 const表示的是指针本身是一个常量， 底层const表示的是指针所指的对象是一个常量。
            const int a;//顶层const

            const int *a;//底层const
            int * const a;//顶层const
            const int &a;//底层const
            更一般情况下，顶层const可以表示任意对象是一个常量，这对于算术类型、类、指针等任何数据类型都是成立的，
            底层 const则与指针和引用等复合类型的基本类型部分有关，
            比较特殊的是，指针既可以是顶层 const也可以是底层 const，这一点与其他类型区别明显。

            2. 顶层 const与底层 const在执行拷贝操作时的不同
8. 进程间的通信
    常见的通信方式
    管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
    命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
    消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
    共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
    信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
    套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
    信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。