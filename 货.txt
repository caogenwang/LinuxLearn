1. 各种排序的思想
    1. 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，
        其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
        实际上交换排序，选择一个基准，比基准小的放在前边，基准大的放在后边。然后再继续递归，继续排序。

        实现思路:从数列中挑出一个元素，称为 “基准”（pivot）；重新排序数列，所有元素比基准值小的摆放在基准前面，
                所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。
                这个称为分区（partition）操作；递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
        代码实现：
            int partition(int *arr,int left,int right){//得到基准值
                int p = arr[left];
                int i = left + 1;
                int j = right;
                while (true){
                    while(i <= j && arr[i] <= p)//找到第一个比基准值大的
                        i ++;
                    while(i <= j && arr[j] >= p)//找到第一个比基准值小的
                        j --;
                    if(i >= j)
                        break;
                    //交换两个元素的位置，使得左边的元素不大于pivot,右边的不小于pivot
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                arr[left] = arr[i];
                arr[i] = p;
                return i;
            }
            void quick(int *arr,int left,int right){
                int mid = partition(arr,left,right);
                arr = quick(arr,left,mid-1);
                arr = quick(arr,mid+1,right);
            }
            int main(){
                int arr[10] = {2,9,5,6,4,8,7,3,1,0};
                arr = quick(arr,0,9);
                display(arr);
            }
            时间复杂度分析:什么时候是O(n^2):
                         什么时候是O(nlogn):
        2. 插入排序（Insertion Sort）:算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，
                                    于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入.在未排序的
                                    数列中选择元素插入已经排序的序列，依次向前扫描。
            算法设计：
                    1. 从第一个元素开始，该元素可以认为已经被排序；
                    2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
                    3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
                    4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
                    5. 将新元素插入到该位置后；
                    6. 重复步骤2~5。

                insert_sort(int*arr)
                {
                    for(int i = 0;i<arr.length - 1;i++)
                    {
                        int j = i;
                        int temp = arr[i + 1];
                        while(j>0 && temp<arr[j]){
                            arr[j] = a[j - 1];
                            j --;
                        }
                        arr[j] = temp;
                    }
                    return arr;
                }
        3. 希尔排序，第一个突破O(n^2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，
                它会优先比较距离较远的元素。希尔排序又叫缩小增量排序.是一种间隔排序。
                希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。
                动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的
                算法设计：
                int shell_sort(vector<int> arr){
                    int gap = arr.size();
                    while(gap > 0){
                        for (int i = 0; i < gap; i++)
                        {   
                            group_sort(array,i,gap);//分组排序
                        }
                        gap = gap/2;
                    }
                }
                void group_sort(vector<int>arr,int i,int gap){
                    for(int j = i + gap;j < arr.size() - gap;j +=gap)
                    {
                        int tmp = a[j];
                        int k = j - gap;//这一段是插入排序
                        while(k > 0 && tmp < arr[k]){
                            a[k + gap] = a[k];
                            k -= gap;
                        }
                        a[k + gap] = tmp;
                    }
                }
            4. 选择排序：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，
                        然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，
                        直到所有元素均排序完毕
                        算法的设计:
                        初始状态：无序区为R[1..n]，有序区为空；
                        第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
                        n-1趟结束，数组有序化了。

                        choose_sort(int test){
                            for (int i = 0; i < 10; i++)
                            {
                                int min = i;
                                for (int j = i+1; j < 10; j++)
                                {
                                    if (test[j] < test[min])//一直都在找一个最小的，然后在交换
                                    {
                                        min = j;
                                    }
                                }
                                int temp = test[i];
                                test[i] = test[min];
                                test[min] = temp;
                            }
                        }
                5、归并排序（Merge Sort）该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
                    将已有序的子序列合并，得到完全有序的序列；
                    即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并
                    算法设计：
                        1. 把长度为n的输入序列分成两个长度为n/2的子序列；
                        2. 对这两个子序列分别采用归并排序；
                        3. 将两个排序好的子序列合并成一个最终的排序序列。
                    
                merge_sort(vector<int> arr,int left,int right){
                    if(left < right){
                        int mid = (left + right) / 2;
                        arr1 = merge_sort(arr,left,mid);
                        arr2 = merge_sort(arr,mid+1,right);
                        merge(arr1,arr2)
                    }
                }
                vector<int> merge(vector<int>&v1,vector<int>&v2)
                {
                    int len = max(v1.size(),v2.size());
                    vector<int> v3(len,0);
                    int i = 0;
                    int j = 0;
                    int m = 0;
                    while(i < v1.size() && j < v2.size()){
                        if(arr[i] > arr[j])
                            v3[m++] = i++;
                        else
                            v3[m++] = j++;
                    }
                    while(i < v1.size())
                        v3[m++] = i++;
                    while(j < v2.size())
                         v3[m++] = j++;

                    return v3;
                }

                6. 堆排序:指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：
                    即子结点的键值或索引总是小于（或者大于）它的父节点.
                    算法设计：
                            1).将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
                            2).将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
                            3).由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，
                                然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。
                                不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。
                    heap_sort(int arr[10],int length){
                        int arr[10] = {{2,9,5,6,4,8,7,3,1,0}};
                        //在一个数组中的父子关系，父是n，则子是2*n+1，和2*n+2
                        //构建大顶堆
                        for (int i = ((length - 1) -1)/2; i >=0; i--)
                        {
                            downAdjust(a,i,length - 1);
                        }
                        for(int i = length - 1;i >= 1;i--){
                            int tmp = a[i];
                            a[i] = a[0];
                            a[0] = tmp;
                            downAdjust(a,0,i - 1);
                        }
                    }
                    void downAdjust(int arr,int parent,int range)
                    {
                        int tmp = arr[parent];
                        int child = 2 * parent + 1;
                        while(child <= n){
                            if(child + 1 <= n && a[child] < a[child + 1])
                                child ++;
                            if(tmp > child)
                                break;
                            arr[parent] = arr[child]
                            parent = child;
                            child = 2*parent + 1;
                        }
                        arr[parent] = tmp;
                    }
                7. 冒泡排序
                8. 计数排序:其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 
                    作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数.
2. 分布式唯一id的生成方法
    1. 数据库自增长序列或字段
    2. UUID
    3. Redis生成ID
            可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。
            可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5
    4. Twitter的snowflake算法
    5. 利用zookeeper生成唯一ID
    6. MongoDB的ObjectId

3. c++内存的分配方式
    C++内存分配的方式有三种：分别是从静态存储区分配，从栈上分配内存和从堆上分配内存
    1. 从静态存储区分配内存
        从静态存储区域分配的内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。
        例如全局变量，static变量。静态分配的区域的生命期是整个软件运行期，
        就是说从软件运行开始到软件终止退出。只有软件终止运行后，这块内存才会被系统回收。
    2. 从栈上分配内存
        在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。
        栈内存分配运算内置于处理器的指令集中，效率很高，但 是分配的内存容量有限。在栈中分配的空间的
        生命期与这个变量所在的函数和类相关。如果是函数中定义的局部变量，那么它的生命期就是函数被调用时，
        如果函数运行结束，那么这块内存就会被回收。如果是类中的成员变量，则它的生命期与类实例的生命期相同。
    3. 从堆上分配内存
        称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，
        程序员自己负责在何时用free或delete释放内存。动态内存的生存 期由我们决定，使用非常灵活，
        但问题也最多。在堆上分配的内存，生命期是从调用new或者malloc开始，到调用delete或者free结束。
        如果不 掉用delete或者free。则这块空间必须到软件运行结束后才能被系统回收。
    
    C++内存布局，也就是一个由c/C++编译的程序占用的内存分为以下几个部分：
    1、栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量值等，其操作方法类似数据结构中的栈。
    2、堆区（heap）：一般由程序员分配释放，与数据结构中的堆毫无关系，分配方式类似于链表。
    3、全局/静态区（static）：全局变量和静态变量的存储是放在一起的，在程序编译时分配。
    4、文字常量区：存放常量字符串。
    5、程序代码区：存放函数体（类的成员函数、全局函数）的二进制代码


4. c++重载和重写的区别
    重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，
        根据参数列表确定调用哪个函数，重载不关心函数返回类型.
    隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏
    
    重写(覆盖)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，是虚函数
            所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），
            派生类调用时会调用派生类的重写函数，不会调用被重写函数。
            重写的基类中被重写的函数必须有virtual修饰。

    重载和重写的区别：
    （1）范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。
    （2）参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。
    （3）virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，
        也可以没有。
    
    隐藏和重写，重载的区别：
    （1）与重载范围不同：隐藏函数和被隐藏函数在不同类中。
    （2）参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，
            无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。


5. define和const区别
    (1) 编译器处理方式不同
    　　define宏是在预处理阶段展开。
    　　const常量是编译运行阶段使用。
    (2) 类型和安全检查不同
    　　define宏没有类型，不做任何类型检查，仅仅是展开。
    　　const常量有具体的类型，在编译阶段会执行类型检查。
    (3) 存储方式不同
    　　define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（是立即数，使用一次分配一次）
    　　const常量会在内存中分配(可以是堆中也可以是栈中)。（第一次使用时才分配，之后不再分配）
    (4)const 可以节省空间，避免不必要的内存分配。
   
    const 比 #define有哪些优点：
    两者都可以用来定义常量，分别是const常量和宏常量
    （1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。
        而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。
    （2）可以对const常量进行调试，但是不能对宏常量进行调试。
    （3）const常量更有效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，
        这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。
6. 为什么用const引用
        （1）&是为了引用传递，防止值传递的复制数据，const是为了保护数据不被改动。
            const&防止传值时拷贝构造函数的调用开销
        （2）形参的对象为顶层const时，传入的实参既可以是const值，又可以是非const值，若是底层const，传入的实参只能是const的值。
            顶层 const表示的是指针本身是一个常量， 底层const表示的是指针所指的对象是一个常量。
            const int a;//顶层const

            const int *a;//底层const
            int * const a;//顶层const
            const int &a;//底层const
            更一般情况下，顶层const可以表示任意对象是一个常量，这对于算术类型、类、指针等任何数据类型都是成立的，
            底层 const则与指针和引用等复合类型的基本类型部分有关，
            比较特殊的是，指针既可以是顶层 const也可以是底层 const，这一点与其他类型区别明显。

            2. 顶层 const与底层 const在执行拷贝操作时的不同
8. 进程间的通信
    常见的通信方式
    管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
    命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
    消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
    共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
    信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
    套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
    信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。