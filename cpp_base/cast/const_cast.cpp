#include <iostream>
using namespace std;

//在C语言中，const限定符通常被用来限定变量，用于表示该变量的值不能被修改
/*
而const_cast则正是用于强制去掉这种不能被修改的常数特性，
但需要特别注意的是const_cast不是用于去除变量的常量性，
而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用.
注意:针对的是指针和引用

*/

// 用法：const_cast<type_id> (expression)

// 该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。
// 常量指针被转化成非常量指针，并且仍然指向原来的对象；
// 常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。

//[例3]一个错误的例子：

//const int a = 10;
//const int * p = &a;
//*p = 20;                  //compile error,p是一个const指针，指向的地址里的内容不能通过p来修改
//int b = const_cast<int>(a);  //compile error，不能对变量进行const去除


int main(){

    // const int a = 10;
    // const int * p = &a;
    // *p = 20;                  //compile error,p是一个const指针，指向的地址里的内容不能通过p来修改
    // int b = const_cast<int>(a); //compile error，不能对变量进行const去除

    const int a = 10;
    const int *p = &a;

    int *q;
    // q = p;//compile error,assigning to 'int *' from incompatible type 'const int *'
    q = const_cast<int *>(p);//去掉p的const属性，还原成int类型
    *q = 20;
    cout<<a<<" "<<*p<<" "<<*q<<endl;//10 20 20,为什么a的值没有改变？
    cout<<&a<<" "<<p<<" "<<q<<endl;//0x7ffeeb3724f8 0x7ffeeb3724f8 0x7ffeeb3724f8
    return 0;
}
// 在本例中，我们将变量a声明为常量变量，同时声明了一个const指针指向该变量
// （此时如果声明一个普通指针指向该常量变量的话是不允许的，Visual Studio 2010编译器会报错）。

// 之后我们定义了一个普通的指针*q。将p指针通过const_cast去掉其常量性，并赋给q指针。
// 之后我再修改q指针所指地址的值时，这是不会有问题的。

// 最后将结果打印出来，运行结果如下：
// 10 20 20
// 002CFAF4 002CFAF4 002CFAF4

// 查看运行结果，问题来了，指针p和指针q都是指向a变量的，指向地址相同，而且经过调试发现002CFAF4地址内的值确实
// 由10被修改成了20，这是怎么一回事呢？为什么a的值打印出来还是10呢？
// 其实这是一件好事，我们要庆幸a变量最终的值没有变成20！变量a一开始就被声明为一个常量变量，不管后面的程序怎么处理，
// 它就是一个常量，就是不会变化的。试想一下如果这个变量a最终变成了20会有什么后果呢？对于这些简短的程序而言，
// 如果最后a变成了20，我们会一眼看出是q指针修改了，但是一旦一个项目工程非常庞大的时候，在程序某个地方出现了一个
// q这样的指针，它可以修改常量a，这是一件很可怕的事情的，可以说是一个程序的漏洞，毕竟将变量a声明为常量就是不希望
// 修改它，如果后面能修改，这就太恐怖了。
// 在例4中我们称“*q=20”语句为未定义行为语句，所谓的未定义行为是指在标准的C++规范中并没有明确规定这种语句的具体行为，
// 该语句的具体行为由编译器来自行决定如何处理。对于这种未定义行为的语句我们应该尽量予以避免！
// 从例4中我们可以看出我们是不想修改变量a的值的，既然如此，定义一个const_cast关键字强制去掉指针的常量性到底有什么
// 用呢？我们接着来看下面的例子。




