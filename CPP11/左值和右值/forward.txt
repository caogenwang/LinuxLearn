一、理解引用折叠　
（一）引用折叠
　　1. 在C++中，“引用的引用”是非法的。像auto& &rx = x;（注意两个&之间有空格）这种直接定义引用的引用是不合法的，
        但是编译器在通过类型别名或模板参数推导等语境中，会间接定义出“引用的引用”，这时引用会形成“折叠”。
　　2. 引用折叠会发生在模板实例化、auto类型推导、创建和运用typedef和别名声明、以及decltype语境中。
（二）引用折叠规则
　　1. 两条规则
　　　　（1）所有右值引用折叠到右值引用上仍然是一个右值引用。如X&& &&折叠为X&&。
　　　　（2）所有的其他引用类型之间的折叠都将变成左值引用。如X& &, X& &&, X&& &折叠为X&。可见左值引用会传染，
            沾上一个左值引用就变左值引用了。根本原因：在一处声明为左值，就说明该对象为持久对象，
            编译器就必须保证此对象可靠（左值）。
　　2. 利用引用折叠进行万能引用初始化类型推导
　　　　（1）当万能引用（T&& param）绑定到左值时，由于万能引用也是一个引用，而左值只能绑定到左值引用。
            因此，T会被推导为T&类型。从而param的类型为T& &&，引用折叠后的类型为T&。
　　　　（2）当万能引用（T&& param）绑定到右值时，同理，右值只能绑定到右值引用上，故T会被推导为T类型。
            从而param的类型就是T&&（右值引用）。

【编程实验】引用折叠
二、完美转发
（一）std::forward原型
    template<typename T>
    T&& forward(typename remove_reference<T>::type& param)
    {
        return static_cast<T&&>(param); //可能会发生引用折叠！
    }
（二）分析std::forward<T>实现条件转发的原理（以转发Widget类对象为例）
　1. 当传递给func函数的实参类型为左值Widget时，T被推导为Widget&类别。然后forward会实例化为std::forward<Widget&>，
        并返回Widget&（左值引用，根据定义是个左值！）
　　2. 而当传递给func函数的实参类型为右值Widget时，T被推导为Widget。然后forward被实例化为std::forward<Widget>，
        并返回Widget&&（注意，匿名的右值引用是个右值！）
　　3. 可见，std::forward会根据传递给func函数实参（注意，不是形参）的左/右值类型进行转发。当传给func函数左值实参时，
        forward返回左值引用，并将该左值转发给process。而当传入func的实参为右值时，forward返回右值引用，并将该右值转发给process函数。
【编程实验】不完美转发和完美转发
三、std::move和std::forward
（一）两者比较
　　1. move和forward都是仅仅执行强制类型转换的函数。std::move无条件地将实参强制转换成右值。而std::forward则仅在某个特定条件满足时（传入func的实参是右值时）才执行强制转换。
　　2. std::move并不进行任何移动，std::forward也不进行任何转发。这两者在运行期都无所作为。它们不会生成任何可执行代码，连一个字节都不会生成。
（二）使用时机
　　1. 针对右值引用的最后一次使用实施std::move，针对万能引用的最后一次使用实施std::forward。
　　2. 在按值返回的函数中，如果返回的是一个绑定到右值引用或万能引用的对象时，可以实施std::move或std::forward。因为如果原始对象是一个右值，它的值就应当被移动到返回值上，而如果是左值，就必须通过复制构造出副本作为返回值。
（三）返回值优化（RVO）
　　1.两个前提条件
　　　　（1）局部对象类型和函数返回值类型相同；
　　　　（2）返回的就是局部对象本身（含局部对象或作为return 语句中的临时对象等）
　　2. 注意事项
　　　　（1）在RVO的前提条件被满足时，要么避免复制，要么会自动地用std::move隐式实施于返回值。
　　　　（2）按值传递的函数形参，把它们作为函数返回值时，情况与返回值优化类似。编译器这里会选择第2种处理方案，即返回时将形参转为右值处理。
　　　　（3）如果局部变量有资格进行RVO优化，就不要把std::move或std::forward用在这些局部变量中。因为这可能会让返回值丧失优化的机会。
【编程实验】RVO优化和std::move、std::forward

三、std::move和std::forward

（一）两者比较

　　1. move和forward都是仅仅执行强制类型转换的函数。std::move无条件地将实参强制转换成右值。而std::forward则仅在某个特定条件满足时（传入func的实参是右值时）才执行强制转换。

　　2. std::move并不进行任何移动，std::forward也不进行任何转发。这两者在运行期都无所作为。它们不会生成任何可执行代码，连一个字节都不会生成。

（二）使用时机

　　1. 针对右值引用的最后一次使用实施std::move，针对万能引用的最后一次使用实施std::forward。

　　2. 在按值返回的函数中，如果返回的是一个绑定到右值引用或万能引用的对象时，可以实施std::move或std::forward。因为如果原始对象是一个右值，它的值就应当被移动到返回值上，而如果是左值，就必须通过复制构造出副本作为返回值。

（三）返回值优化（RVO）
　　1.两个前提条件
　　　　（1）局部对象类型和函数返回值类型相同；
　　　　（2）返回的就是局部对象本身（含局部对象或作为return 语句中的临时对象等）
　　2. 注意事项
　　　　（1）在RVO的前提条件被满足时，要么避免复制，要么会自动地用std::move隐式实施于返回值。
　　　　（2）按值传递的函数形参，把它们作为函数返回值时，情况与返回值优化类似。编译器这里会选择第2种处理方案，即返回时将形参转为右值处理。
　　　　（3）如果局部变量有资格进行RVO优化，就不要把std::move或std::forward用在这些局部变量中。因为这可能会让返回值丧失优化的机会。
【编程实验】RVO优化和std::move、std::forward

四、完美转发失败的情形
（一）完美转发失败
　　1. 完美转发不仅转发对象，还转发其类型、左右值特征以及是否带有const或volation等修饰词。而完美转发的失败，主要源于模板类型推导失败或推导的结果是错误的类型。
　　2. 实例说明：假设转发的目标函数f，而转发函数为fwd（天然就应该是泛型）。函数如下：
（二）五种完美转发失败的情形
　　1. 使用大括号初始化列表时
　　（1）失败原因分析：由于转发函数是个模板函数，而在模板类型推导中，大括号初始不能自动被推导为std::initializer_list<T>。
　　（2）解决方案：先用auto声明一个局部变量，再将该局部变量传递给转发函数。
　　2. 0和NULL用作空指针时
　　（1）失败原因分析：0或NULL以空指针之名传递给模板时，类型推导的结果是整型，而不是所希望的指针类型。
　　（2）解决方案：传递nullptr，而非0或NULL。
　　3. 仅声明static const 整型成员变量，而无其定义时。
　　（1）失败原因分析：C++中常量一般是进入符号表的，只有对其取地址时才会实际分配内存。调用f函数时，其实参是直接从符号表中取值，此时不会发生问题。但当调用fwd时由于其形参是万能引用，而引用本质上是一个可解引用的指针。因此当传入fwd时会要求准备某块内存以供解引用出该变量出来。但因其未定义，也就没有实际的内存空间， 编译时可能失败（取决于编译器和链接器的实现）。
　　（2）解决方案：在类外定义该成员变量。注意这声变量在声明时一般会先给初始值。因此定义时无需也不能再重复指定初始值。
　　4. 使用重载函数名或模板函数名时
　　（1）失败原因分析：由于fwd是个模板函数，其形参没有任何关于类型的信息。当传入重载函数名或模板函数（代表许许多多的函数）时，就会导致fwd的形参不知绑定到哪个函数上。
　　（2）解决方案：在调用fwd调用时手动为形参指定类型信息。
　　5. 转发位域时
　　（1）失败原因分析：位域是由机器字的若干任意部分组成的（如32位int的第3至5个比特），但这样的实体是无法直接取地址的。而fwd的形参是个引用，本质上就是指针，所以也没有办法创建指向任意比特的指针。
　　（2）解决方案：制作位域值的副本，并以该副本来调用转发函数。

【编程实验】完美转发失败的情形及解决方案