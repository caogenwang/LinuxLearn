一. std::move
（一）std::move的原型
    template<typename T>
    decltype(auto) move(T&& param)  //注意，形参是个引用（万能引用）
    {
        using ReturnType = typename remove_reference<T>::type&&; //去除T自身可能携带的引用
        return static_cast<ReturnType>(param); //强制转换为右值引用类型
    }
  二）注意事项
   　1. std::move的本质就强制类型转换，它无条件地将实参转为右值引用类型（匿名对象，是个右值），
        继而用于移动语义。
   　2. 该函数只是将实参转为右值，除此之外并没有真正的move任何东西。实际上，它在运行期没任何作为，
        编译器也不会为它生成任何的可执行代码，连一个字节都没有。
   　3. 如果要对某个对象执行移动操作时，则不要将其声明为常量。因为针对常量对象执行移动操作将变成复制操作。
二. 移动语义
（一）深拷贝和移动的区别
    1.深拷贝：将SrcObj对象拷贝到DestObj对象，需要同时将Resourse资源也拷贝到DestObj对象去。这涉及到内存的拷贝。
    2.移动：通过“偷”内存的方式，将资源的所有权从一个对象转移到另一个对象上。但只是转移，并没有内存的拷贝。
    可见Resource的所有权只是从SrcObj对象转移到DestObj对象，由于不存在内存拷贝，其效率一般要高于复制构造。
（二）复制和移动操作函数
    1.复制/移动操作的函数声明
        ①Object(T&);       //复制构造，仅接受左值
        ②Object(const T&); //复制构造，即可以接受左值又可接收右值
        ③Object(T&&) noexcept; //移动构造，仅接受右值
        ④T& operator=(const T&);//复制赋值函数，即可以接受左值又可接收右值
        ⑤T& operator=(T&&); //移动赋值函数，仅接受右值
    2.注意事项
        ①移动语义一定是要修改临时对象的值，所以声明移动构造时应该形如Test(Test&&)，而不能声明为Test(const Test&&)
        ②默认的移动构造函数实际上跟默认的拷贝构造函数一样，都是“浅拷贝”。通常情况下，必须自定义移动构造函数。
        ③对于移动构造函数来说，抛出异常是很危险的。因为移动语义还没完成，一个异常就抛出来，可能会造成悬挂指针。因此，应尽量通过noexcept声明不抛出异常，而一旦出现异常就可以直接调用std::terminate终止程序。
        ④特殊成员函数之间存在相互抑制的生成机制，可能会影响到默认拷贝构造和默认移动构造函数的自动生成。（详见《特殊成员函数的生成机制》一节）

【编程实验】move移动语义
