一. lambda表达式
（一）语法定义：[capture](paramters) mutable ->returnType{statement}
　　1.[capture]：捕获列表
　　（1）lambda函数只能捕获父作用域中的局部变量或形参。而捕获非父作用域或静态变量则会出错。
        （这里的父作用域指的是包含lambda函数的语句块，如main函数作用域）
　　　　①[]：表示不捕获；[=]和[&]：分别表示按值和按引用捕获所有父作域变量（包括this）；
　　　　②[var]、[&var]分别表示按值和按引用捕获var。注意，默认是无法修改按值捕获的变量的值
        （因为lambda表达式的operator()默认为const）。
　　　　③[=,&foo]：表示按引用捕获foo变量，按值捕获父作用域中所有其它变量。
　　　　④[this]：捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样访问权限。
        捕获this的目的是可以在lambda中会使用当前类的成员函数和成员变量。
    (2)注意事项：
　　　　①捕获列表不允许变量重复传递。如[=,a]、[&,&this]其中的a和this都被重复传递。
　　　　②lambda表达式的按值捕获，是在声明lambda表达式的一瞬间就被复制了。如果希望lambda表达式在调用时能即时的访问外部变量，应该使用按引用捕获。
　　　　③默认情况下，按值捕获的变量是不可以被修改的，因为lambda表达式的operator()是个const函数。
　　　　④lambda不能捕获非父作用域变量或static变量。即它们不能被进入捕获列表中，但可在lambda的函数体内直接访问。
    2.(parameters)：参数列表。
    （1）与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号（）一起省略。
　　 （2）参数列表不支持默认值，也不支持可变参数。所有的参数必须有参数名。
　　 （3）C++14中，参数类型可以声明为auto类型。
    3. mutable：默认下，lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，
        参数列表不可省略（即使参数为空）
    4.returnType：返回值类型。用追踪返回类型形式声明函数的返回类型。在返回类型明确的情况下，
        也可以省略该部分，让编译器对返回类型进行自动推导。如果没有return语句则返回void。
    5.{statement}：函数体。内容与普通函数一样，除了可以使用参数之外，还可以使用所有捕获的变量。

     1. 仿函数是编译器实现lambda表达式的一种方式。在现阶段，通常编译器都会把lambda表达式转化成为一个仿函数对象。因此，在C++11中，lambda可以视为仿函数的一种等价形式或叫“语法糖”。
  　　2. 两者虽然在语法层面上不同，但却有着相同的内涵为——都可以捕捉一些变量作为初始状态并接受参数进行运算。
  　　3. lambda表达式在C++11中被称为“闭包类型（Closure Type）”，可以认为是个仿函数，带有const属性的operator()。它的捕获列表捕获的任何外部变量最终均会变为仿函数的成员变量。由闭包类型定义的对象称为“闭包”（是个右值）。
    　4. 没有捕获变量的lambda表达式可以直接转换为函数指针，而捕获变量的lambda表达式则不能转换为函数指针。
（1）泛型lambda的格式形如 [](auto x, auto y){}; 或 [](auto&& x, auto&& y){} 等。
　　（2）由于auto&&类型的形参没有可用的T类型，泛型lambda采用forward+decltype来转发param。
　　（3）当param被左值实参初始化时，param被推导为左值引用，即decltype(param)为左值引用类型。同理，当param被右值初始化时，即decltype(param)为右值引用类型。
　　（4）decltype(param)作为模板形参传入std::forward时，会发生引用折叠，从而能正确根据实参的左/右值特性进行转发。
　　2. 泛型lambda的优势
　　（1）使用auto作为lambda函数的参数类型修饰符，增加泛型编程能力；
　　（2）泛型lambda允许带auto参数的lambda函数能够转化为函数指针。
【编程实验】泛型lambda
