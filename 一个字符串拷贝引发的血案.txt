问题:在做字符串切割的时候，会用到memcpy函数，每次拷贝都会出现某个拷贝完成后的字符出现多余字符，造成乱码，而且出现在不同的
    字符身上，是偶尔出现，不会稳定出现在某个字符上。以下是解决的问题的方案



C语言：memcpy复制字符串长度变大了【变长】，怎么回事？ (2017-08-02 18:52:27)转载▼
memcpy或memcpy_s复制字符串长度变大了，怎么回事？

如下代码会出现数据问题，导致复制出来的字符串，变长了，尾部被增加了一些东西。

 int len=10;
 char  dataSrc[10]="1234567890";
 char* Dst=(char*)alloc(len);
 memset(Dst,0,len);

 memcpy(Dst,dataSrc,len);
 printf("Dst=[%s]",Dst)
 这个时候你输出的肯定是：
Dst=[1234567890  XXX]

字符串后面增加了一些尾巴：如果复制长度刚好等于目标长度，则会出现Dst最后一个字节Dst[9]的0值被覆盖了。
这就导致了Dst的结束标志被破坏，那么当你输出Dst的内容的时候，系统一定要找到一个0值才会停下来，所以理论上，上述打印出来的尾巴是随机的，什么情况都有可能，但是可以肯定的是长度一定是变长了。

解决办法是：
char* Dst=(char*)alloc(len+1);//为结束标记提供一个独立的位置即可