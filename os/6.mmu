1. 
又是信息量爆炸的一节，不过读下来也是挺爽的。这里我替很多同学说明一下，虚拟地址中的页内偏移才是决定页大小和多级目录的核心点，
页内偏移必须与页大小保持一致，这样才能保证寻址可以找到页内的每一个地址。
对于思考题，其实也比较简单，文中也谈到了，实模式下多个任务共享所有地址空间太危险，因此才有了保护模式，
保护模式下的分页模式是一个巨大的创新。
对于每个进程而言，它会误认为(被操作系统欺骗)自己独有所有地址空间，因此它访问地址是不会考虑任何问题的，
可是这个地址是虚拟地址，待被MMU翻译后会得到对应的页表，而这个页表由操作系统管理，不同的进程拥有不同的页表，
也因此产生了进程地址空间隔离，但是多个进程也是可以共享某个页表，这也是进程通信(IPC)的根本手段。

2.
多个进程隔离应该是操作系统进行任务切换时会改写CPU的页表基地址寄存器为当前被运行进程的页表基地址吧！

3. 
每一个进程会有不同的页表内容。
在32位的windows系统中虚拟地址2g到4g空间都是系统函数调用空间，这部分的对应的物理空间是同一块区域。
但低端虚拟内存空间各个进程空间对应的物理地址不相同，所以进程间的页表有部分相同，有部分是不同的。
另外32位的xp系统是可以设置成1g的系统内存空间的，也就是进程的私有空间由0到2g的范围变成了0到3g的虚拟空间。与上面的描述又有些变化了。
到了64位好像是128T的虚拟内存空间的是进程私有虚拟内存空间。

我理解的是操作系统会给每个进程分配好页表，页表里面的相关物理地址也都会准备好，这样当进程进行虚拟地址转换时，
mmu通过这个转换关系表(页表)找到对应的物理地址，那缺页是找不到对应的转换关系吗？不知道理解的对不对

1. 每个应用程序都有自己的地址空间，但是这个地址是虚拟的地址。
2. 当应用程序访问某个虚拟地址时：
假如我能探测地址总线，我并不会在地址总线上测到对应的的物理信号。
地址总线上的物理信号是物理地址一一对应的。
而虚拟地址需要通过MMU转换为物理地址。

3. MMU保证相同的虚拟地址不会访问到相同的物理内存。
MMU也保证不同的虚拟地址不会访问到相同的物理内存。

4. 从而保证了在物理地址空间上，应用程序是隔离的。