网络编程:
1.nagle 算法；
    是为了减少广域网的小分组数目，从而减小网络拥塞的出现;该算法要求一个tcp连接上最多只能有一个
    未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组，tcp需要收集这些少量的分组，
    并在ack到来时以一个分组的方式发送出去；其中小分组的定义是小于MSS的任何分组.该算法的优越之处在于它是自适应的，
    确认到达的越快，数据也就发哦送的越快；而在希望减少微小分组数目的低速广域网上，则会发送更少的分组。
    如果延迟ACK和nagle算法相遇，会导致访问数据经过较长时间送达。

2. keepalive 选项；
   tcp的长连接，通过定时发送keepalive包，维持两端的连接，不把连接销毁，是一种保活的机制。

3. Linger 选项；
    SO_LINGER选项用来设置延迟关闭的时间，等待套接字发送缓冲区中的数据发送完成。没有设置该选项时，
    在调用close()后，在发送完FIN后会立即进行一些清理工作并返回。如果设置了SO_LINGER选项，
    并且等待时间为正值，则在清理之前会等待一段时间。
    从这里看来，SO_LINGER选项的作用是等待发送缓冲区中的数据发送完成，但是并不保证发送缓冲区中的数据一定被对端接收
    （对端宕机或线路问题），只是说会等待一段时间让这个过程完成。如果在等待的这段时间里接收到了带数据的包，
    还是会给对端发送RST包，并且会reset掉套接字，因为此时已经关闭了接收通道

4.对于某一端出现大量CLOSE_WAIT或者TIME_WAIT如何解决；
    CLOSE_WAIT：服务段被动断开一端
    TIME_WAIT：客户端断开连接一端，

5.通讯协议如何设计或如何解决数据包的粘包与分片问题；
    https://blog.csdn.net/qq513036862/article/details/53640317

    二：产生上情况的内部原因有下面几点：
    1.数据发送端发送数据给缓冲buffer太大，导致发送一个完整的数据包被分几次发送给缓存buffer，然而缓冲buffer等到数据满了以后会自动把数据发送的数据链路层去，这样就导致分包了。
    2.TCP协议定义有一个选项叫做最大报文段长度（MSS，Maximum Segment Size），该选项用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。在一定程度上MSS应该能尽可能多地承载用户数据，用于在传输通路上又可能避免分片，但是在复杂的网络环境下确定这个长度值非常困难，那么在这样的情况下在传输过程中产生分包，粘包就很常见了
    3.以太网，IP,TCP,UDP数据包分析大家可以仔细圆研究这篇文章http://www.cnblogs.com/feitian629/archive/2012/11/16/2774065.html
    4.数据帧的有效载荷(payload)比以太网的最大传输单元（MTU）大的时候，进行了IP分片。

    三：解决数据分包和粘包的基本策略如下
    1.消息定长，比如定一个100，那么读取端每次读取数据就截取100个长度的数据，然后交给业务成去做解析
    2.在消息的尾部加一些特殊字符，那么在读取数据的时候，只要读到这个特殊字符，
        就认为已经可以截取一个完整的数据包了，这种情况在一定的业务情况下实用。
    3.读取缓存的数据是不定长的，所以我们把读取到的数据添加到我们自己的一个byte[]数组中，
        然后根据我们的业务逻辑来找到指定的特殊协议头部，协议长度，协议尾部，然后从我们的byte[]中获取一个完整的数据包，
        然后再对数据包进行业务解析就可以得到正确结果。

6.心跳机制如何设计；（可能不会直接问问题本身，如问如何检查死链）

7.断线重连机制如何设计；

8.对 IO Multiplexing 技术的理解；

9.收发数据包正确的方式，收发缓冲区如何设计；

10.优雅关闭；

11.定时器如何设计；

12.epoll 的实现原理。

13. TCP之LAST_ACK状态
    前提：
    A：主动关闭；
    B：被动关闭；
    A执行主动关闭，发送FIN，B收到FIN，发送ACK，进入CLOSE_WAIT，B发送FIN，进入LAST_ACK等待最后一个ACK到来；

    关闭方式：
    (1) 收到A发送回来的ACK进入CLOSED状态；
    (2) 未收到A发送回来的ACK，重传FIN，此时A处于FIN_WAIT_2(之前B发的FIN丢了)或者TIME_WAIT(之前A发的ACK丢了)，
        A收到FIN之后，发送ACK，B收到ACK，进入CLOSED状态；
    (3) 未收到A发送回来的ACK，重传FIN，此时A已经进入CLOSED状态，因连接丢失，A回复RST，B收到RST进入CLOSED状态；

14. close_wait状态的产生原因及解决
    如果我们的服务器程序处于CLOSE_WAIT状态的话，说明套接字是被动关闭的！
    因为如果是CLIENT端主动断掉当前连接的话，那么双方关闭这个TCP连接共需要四个packet：
    1.Client -> FIN  -> Server  
    2.Client <- ACK  <- Server   这时候Client端处于FIN_WAIT_2状态；而Server 程序处于CLOSE_WAIT状态。  
    3.Client <- FIN  <- Server   这时Server 发送FIN给Client，Server 就置为LAST_ACK状态。  
    4.Client -> ACK  -> Server   Client回应了ACK，那么Server 的套接字才会真正置为CLOSED状态

    Server 程序处于CLOSE_WAIT状态，而不是LAST_ACK状态，说明还没有发FIN给Client，那么可能是在关闭连接之前还有许多数据要发送或者其他事要做，
    导致没有发这个FIN packet。
    通常来说，一个CLOSE_WAIT会维持至少2个小时的时间（这个时间外网服务器通常会做调整，要不然太危险了）。
    如果有个流氓特地写了个程序，给你造成一堆的CLOSE_WAIT，消耗你的资源，那么通常是等不到释放那一刻，系统就已经解决崩溃了。
    只能通过修改一下TCP/IP的参数，来缩短这个时间：修改tcp_keepalive_*系列参数有助于解决这个问题。
    但是实际上，还是主要是因为我们的程序代码有问题，通常是如下问题：
    比如被动关闭的是客户端。。。

    我的理解，当主动关闭的一方发送FIN到被动关闭这边后，被动关闭这边的 TCP马上回应一个ACK过去，
    同时向上面应用程序提交一个ERROR，
    导致上面的SOCKET的send或者recv返回SOCKET_ERROR，正常情况下，如果上面在返回SOCKET_ERROR后调用了 
    closesocket,那么被动关闭的者一方的TCP就会发送一个FIN过去，自己的状态就变迁到LAST_ACK.