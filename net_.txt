网络编程:
1.nagle 算法；
    是为了减少广域网的小分组数目，从而减小网络拥塞的出现;该算法要求一个tcp连接上最多只能有一个
    未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组，tcp需要收集这些少量的分组，
    并在ack到来时以一个分组的方式发送出去；其中小分组的定义是小于MSS的任何分组.该算法的优越之处在于它是自适应的，
    确认到达的越快，数据也就发哦送的越快；而在希望减少微小分组数目的低速广域网上，则会发送更少的分组。
    如果延迟ACK和nagle算法相遇，会导致访问数据经过较长时间送达。

2. keepalive 选项；
   tcp的长连接，通过定时发送keepalive包，维持两端的连接，不把连接销毁，是一种保活的机制。

3. Linger 选项；
    SO_LINGER选项用来设置延迟关闭的时间，等待套接字发送缓冲区中的数据发送完成。没有设置该选项时，
    在调用close()后，在发送完FIN后会立即进行一些清理工作并返回。如果设置了SO_LINGER选项，
    并且等待时间为正值，则在清理之前会等待一段时间。
    从这里看来，SO_LINGER选项的作用是等待发送缓冲区中的数据发送完成，但是并不保证发送缓冲区中的数据一定被对端接收
    （对端宕机或线路问题），只是说会等待一段时间让这个过程完成。如果在等待的这段时间里接收到了带数据的包，
    还是会给对端发送RST包，并且会reset掉套接字，因为此时已经关闭了接收通道

4.对于某一端出现大量CLOSE_WAIT或者TIME_WAIT如何解决；
    CLOSE_WAIT：服务段被动断开一端
    TIME_WAIT：客户端断开连接一端，

5.通讯协议如何设计或如何解决数据包的粘包与分片问题；
    https://blog.csdn.net/qq513036862/article/details/53640317

    二：产生上情况的内部原因有下面几点：
    1.数据发送端发送数据给缓冲buffer太大，导致发送一个完整的数据包被分几次发送给缓存buffer，然而缓冲buffer等到数据满了以后会自动把数据发送的数据链路层去，这样就导致分包了。
    2.TCP协议定义有一个选项叫做最大报文段长度（MSS，Maximum Segment Size），该选项用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。在一定程度上MSS应该能尽可能多地承载用户数据，用于在传输通路上又可能避免分片，但是在复杂的网络环境下确定这个长度值非常困难，那么在这样的情况下在传输过程中产生分包，粘包就很常见了
    3.以太网，IP,TCP,UDP数据包分析大家可以仔细圆研究这篇文章http://www.cnblogs.com/feitian629/archive/2012/11/16/2774065.html
    4.数据帧的有效载荷(payload)比以太网的最大传输单元（MTU）大的时候，进行了IP分片。

    三：解决数据分包和粘包的基本策略如下
    1.消息定长，比如定一个100，那么读取端每次读取数据就截取100个长度的数据，然后交给业务成去做解析
    2.在消息的尾部加一些特殊字符，那么在读取数据的时候，只要读到这个特殊字符，
        就认为已经可以截取一个完整的数据包了，这种情况在一定的业务情况下实用。
    3.读取缓存的数据是不定长的，所以我们把读取到的数据添加到我们自己的一个byte[]数组中，
        然后根据我们的业务逻辑来找到指定的特殊协议头部，协议长度，协议尾部，然后从我们的byte[]中获取一个完整的数据包，
        然后再对数据包进行业务解析就可以得到正确结果。

6.心跳机制如何设计；（可能不会直接问问题本身，如问如何检查死链）

7.断线重连机制如何设计；

8.对 IO Multiplexing 技术的理解；

9.收发数据包正确的方式，收发缓冲区如何设计；

10.优雅关闭；

11.定时器如何设计；

12.epoll 的实现原理。