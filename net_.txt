网络编程:
1.nagle 算法；
    是为了减少广域网的小分组数目，从而减小网络拥塞的出现;该算法要求一个tcp连接上最多只能有一个
    未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组，tcp需要收集这些少量的分组，
    并在ack到来时以一个分组的方式发送出去；其中小分组的定义是小于MSS的任何分组.该算法的优越之处在于它是自适应的，
    确认到达的越快，数据也就发哦送的越快；而在希望减少微小分组数目的低速广域网上，则会发送更少的分组。
    如果延迟ACK和nagle算法相遇，会导致访问数据经过较长时间送达。

2. keepalive 选项；
   tcp的长连接，通过定时发送keepalive包，维持两端的连接，不把连接销毁，是一种保活的机制。

3. Linger 选项；
    SO_LINGER选项用来设置延迟关闭的时间，等待套接字发送缓冲区中的数据发送完成。没有设置该选项时，
    在调用close()后，在发送完FIN后会立即进行一些清理工作并返回。如果设置了SO_LINGER选项，
    并且等待时间为正值，则在清理之前会等待一段时间。
    从这里看来，SO_LINGER选项的作用是等待发送缓冲区中的数据发送完成，但是并不保证发送缓冲区中的数据一定被对端接收
    （对端宕机或线路问题），只是说会等待一段时间让这个过程完成。如果在等待的这段时间里接收到了带数据的包，
    还是会给对端发送RST包，并且会reset掉套接字，因为此时已经关闭了接收通道

4.对于某一端出现大量CLOSE_WAIT或者TIME_WAIT如何解决；
    CLOSE_WAIT：服务段被动断开一端
    TIME_WAIT：客户端断开连接一端，

5.通讯协议如何设计或如何解决数据包的粘包与分片问题；
    https://blog.csdn.net/qq513036862/article/details/53640317

    二：产生上情况的内部原因有下面几点：
    1.数据发送端发送数据给缓冲buffer太大，导致发送一个完整的数据包被分几次发送给缓存buffer，然而缓冲buffer等到数据满了以后会自动把数据发送的数据链路层去，这样就导致分包了。
    2.TCP协议定义有一个选项叫做最大报文段长度（MSS，Maximum Segment Size），该选项用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。在一定程度上MSS应该能尽可能多地承载用户数据，用于在传输通路上又可能避免分片，但是在复杂的网络环境下确定这个长度值非常困难，那么在这样的情况下在传输过程中产生分包，粘包就很常见了
    3.以太网，IP,TCP,UDP数据包分析大家可以仔细圆研究这篇文章http://www.cnblogs.com/feitian629/archive/2012/11/16/2774065.html
    4.数据帧的有效载荷(payload)比以太网的最大传输单元（MTU）大的时候，进行了IP分片。

    三：解决数据分包和粘包的基本策略如下
    1.消息定长，比如定一个100，那么读取端每次读取数据就截取100个长度的数据，然后交给业务成去做解析
    2.在消息的尾部加一些特殊字符，那么在读取数据的时候，只要读到这个特殊字符，
        就认为已经可以截取一个完整的数据包了，这种情况在一定的业务情况下实用。
    3.读取缓存的数据是不定长的，所以我们把读取到的数据添加到我们自己的一个byte[]数组中，
        然后根据我们的业务逻辑来找到指定的特殊协议头部，协议长度，协议尾部，然后从我们的byte[]中获取一个完整的数据包，
        然后再对数据包进行业务解析就可以得到正确结果。

6.心跳机制如何设计；（可能不会直接问问题本身，如问如何检查死链）
    https://segmentfault.com/a/1190000006931568

    我们可以通过两种方式实现心跳机制:
        1. 使用 TCP 协议层面的 keepalive 机制.
        2. 在应用层上实现自定义的心跳机制.

        虽然在 TCP 协议层面上, 提供了 keepalive 保活机制, 但是使用它有几个缺点:
        1. 它不是 TCP 的标准协议, 并且是默认关闭的.
        2. TCP keepalive 机制依赖于操作系统的实现, 默认的 keepalive 心跳时间是 两个小时, 
            并且对 keepalive 的修改需要系统调用(或者修改系统配置), 灵活性不够.
        3. TCP keepalive 与 TCP 协议绑定, 因此如果需要更换为 UDP 协议时, keepalive 机制就失效了.

        在应用层设计自己的定时器，可以约定自己每次发送的消息的内容，定义一定的格式；例如redis中的ping报文；
        间隔多久没有收到pong的响应报文，就销毁当前的连接；

7.断线重连机制如何设计；
    顾名思义，就是网络断了以后要进行重连，在网络编程中，断线重连机制是必须要有的，那么怎么设计一个断线重
    连机制呢？

    3.1 程序设置固定重连时间
        有两种情况：
    一是发现断线后立马重连一次，然后间隔2秒后重连，然后是4秒、6秒、8秒等；
    二是2秒，4秒，6秒，8秒这样去重连；
    3.2 让客户设置
    就是在断线后，在界面上弹出窗口让客户自己设置重连间隔，这一点在许多桌面客户端和移动app上都有体现；

    3.3 监控网络状态
    我们可以获得网络情况，如果是网络断开了，那么我们肯定不会去重连，但如果网络一旦好了，我们就要立马重连；

8.对 IO Multiplexing 技术的理解；
    之前程序中使用的IO函数都是同步的，无论阻塞式还是非阻塞式，在数据从内核拷贝到用户空间过程，用户线程都是
    被阻塞的。非阻塞IO只是当内核还没准备好数据时立即返回不等待，需要用户自己去不断检查内核数据是否准备好，
    依然不高效。IO多路复用提出了新的思路，将IO过程分为等待内核数据准备好和读取/写入内核两部分。
    一个IO函数监控多个IO可读/可写事件，任意1个IO设备准备好时返回（需要代码中轮询查看是哪个IO文件描述符，
    什么事件），再调用对应的read/write函数操作，减少不必要的等待时间，高效了很多。
    具体的实现有select、poll和epoll三种。
9.收发数据包正确的方式，收发缓冲区如何设计；

10.TCP优雅关闭；
    优雅关闭：其实就是正常的四次挥手
    非优雅关闭：向对端发送一个RST报文直接进入CLOSED状态.
    服务器为了避免太多TIME_WAIT的关闭方式：
    1.保证由客户端主动发起关闭
    2 .关闭的时候使用RST的方式
    3.对处于TIME_WAIT状态的TCP允许重用
    一般我们当然最好是选择第一种方式，实在没有办法的时候，我们可以使用SO_LINGER选择第二种方式，使用SO_REUSEADDR选择第三种方式

11.定时器如何设计；
    https://blog.csdn.net/qq_32523711/article/details/109168290
    
    二、定时器的概念
    三、排序链表
    四、最小堆（优先队列）
    五、时间轮（环形队列+双向链表）
    五、红黑树（std::set自动排序）
    如何组织数据结构；
12.epoll 的实现原理。