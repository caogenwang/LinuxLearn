
1.
问题一：在Kubernetes 的情况下，是不是该节点上所有的容器都是kubelet 的子进程？不然kubelet 怎么来清理这些容器产生的僵尸进程呢？

问题二：在Docker 的场景下，容器第一个进程是用户自己写的进程，而该进程是不能保证在回收子进程资源上的质量的，所以才有Tinit 等工具，那为什么docker runtime 不默认把这样的回收功能做了呢？

问题三：Linux 为什么不设计成可以kill -9 杀死僵尸进程呢？现在把希望都寄托在父亲进程的代码质量上，而要init 回收，就得把init 到 僵尸进程之间的血缘进程全部杀死。为什么要做这样的设计呢？
作者回复: > 问题一
在kuberenetes下，kubelet还是调用 containerd/runc去启动容器的，每个容器的父进程是containerd-shim, 最终shim可以回收僵尸进程。

> 问题二
docker倒是也做了这件事。 用docker启动容器的时候 加--init参数，起来的容器就强制使用tini作为init进程了。

> 问题三
Linux进程要响应SIGKILL并且执行signal handler，只有在被进程调度到的时候才可以做。对于zombie进程，它已经是不可被调度的进程了。

2.
总结一下这节课相关的东西
1.，父进程在创建完子进程之后就不管了，而每一个 Linux 进程在退出的时候都会进入一个僵尸状态，这时这些进入僵尸状态的进程就因为无法回收变成僵尸进程。
2.僵尸进程是无法直接被kill掉的，需要父进程调用wait()或watipid()回收。
3.清理僵尸进程的两个思路
（1）kill掉僵尸进程的父进程，此时僵尸进程会归附到init(1)进程下，而init进程一般都有正常的wait()或watipid()回收机制。
（2）利用dumb-init/tini之类的小型init服务来解决僵尸进程

3.
僵尸进程也是进程，就是资源没有被回收，父进程还活着就不会被init回收。
补充一点
子进程推出的时候会给父进程发送个信号，如果父进程不处理这个信号就会变味僵尸进程。现在一般只会出现在c这种需要手动垃圾回收得语言了。

老师是踩过坑呢，感觉这个坑不好踩，一是因为高级语言会处理信号，就像上一节说的。还有就是啥业务场景能搞三万多进程
作者回复: @Helios,
对于容器或者说pod, 我们加了pids cgroup的限制，pids.max 对于每个容器一般就是以千为单位了，这个值还是很容易达到上限的。

我们在线上看到的大量Z进程，实际的情况要复杂一些，一个进程有多个线程，主进程处于Z状态，而还有一个线程处于D状态，但是从表象查看进程状态的时候，看到都是<defunct>进程了(Z）。由于有了D的线程在里面，这时候waitpid(), 任何信号对这些进程都无效了。
这一讲，我是把Z进程的概念单独说了一下，对于D进程，它会引起其他的一些现象，我会在后面讲到。

4.
我是一个Docker新手，请教一下老师，经常看到一些容器僵尸，状态栏显示：Exited (2) 10 days ago，Exited (1) 10 days ago，Exited (100) 10 days ago等等，这些容器为啥不能被回收呢？目前只能docker rm清理掉。
作者回复: docker 自己没有自动清理的功能。如果是kubernetes/kubelet是会做清理。

5. 
老师好，
问题1:修改容器的pid.max怎么修改，我看到您直接修改宿主机的一个目录，但是我并没有类似的目录名称。
问题2: for (i = 0; i < total; i++) { int status; wait(&status); } status这个int类型的值都没有被赋值，wait又是如何知道他要回收哪个呢，同样的问题，也在于waitpid。
问题3:既然知道了pid.maxs这个文件，那我有个想法，那就是把宿主机的这个文件无限的改大，那岂不是无限进程启动了，虽然我在宿主机上没找到这个文件。
最后，这居然是一门操作系统的课程，我之前挺害怕os的，现在感觉找到一切切入点了，可以尝试一下学一些原理了，谢谢老师。
作者回复: @朱雯
> 问题1
你可以到 /sys/fs/cgroup/pids 目录下试试搜索一下container id, 或者带docker关键字的目录。

# pwd
/sys/fs/cgroup/pids
# find . -name *7bab7f79d70c*
./system.slice/docker-7bab7f79d70cbf7a59344856eecfb52c1e1d4706d3fbe3e4b74c5172ea7af541.scope
# find . -name docker*
./system.slice/docker.service
./system.slice/docker-7bab7f79d70cbf7a59344856eecfb52c1e1d4706d3fbe3e4b74c5172ea7af541.scope
./system.slice/docker.socket

> 问题2
wait()是不指定要回收哪个pid的，只要是它的子进程退出就可以回收。waitpid()是有参数pid的，可以指定要回收的进程。

> 问题3
把pid.maxs改成无限大，那么如果真的有海量进程在系统中，那么从内核内存，进程的调度，都会出现更多的问题或者系统直接就死了。

> 最后，这居然是一门操作系统的课程，我之前挺害怕os的，现在感觉找到一切切入点了
的确是这样的，很多容器的问题就是归结到OS的问题。学习容器也是一个很好的学习OS的切入点！

6.
老师，还有个问题，如果在发生操作系统或者容器中有很多僵尸进程，现场快速的解决办法是通过sigterm或者sigkill暂时杀掉僵尸进程解决问题吗？
作者回复: SIGTERM/SIGKILL这时候是不能够杀死僵尸进程了。只能依靠父进程的wait/waitpid去回收。

7.

老师的这个问题，我的理解是每个人只对自己的孩子负责，爷爷只管爸爸，爸爸只管孙子，爷爷不管孙子，如果爸爸挂了，爷爷就会代管孙子，所以init不会去回收C。

我还有几个问题：
问题A: 如果init没有waitpid()或者wait()功能，那么僵尸进程是不是就不能回收了？

问题B: 像在容器中，产生僵尸进程是应用的问题吧？容器平台并不能解决僵尸进程的问题，需要开发介入吧？

问题C：我在一个博客上看到一句话：如果父进程在子进程之前退出，子进程会变成孤儿进程, 它的父进程会变成 PID 1。因此，init 进程就要对这些进程负责，并在适当的时候调用 wait() 方法。但是，通常情况下，大部分进程不会处理偶然依附在自己进程上的随机子进程，所以在容器中，会出现许多僵尸进程。让所有的应用能正确的处理以上的情况，不太现实。好在现在有很多解决方案，例如dumb-init [0] 。他像是一个小型 init 服务，他启动一个子进程并转发所有接收到的信号量给子进程。而且不需要修改应用代码。此时你的应用进程已经不是 pid 1 了，所以已经没有上面提到的问题。而且 dumb-init
也会转发所有的信号给子进程，应用的形为和在没有 dumb-init 时是一样的。如果应用进程死掉了，dumb-init 进程也会死掉，并会清理所有其它的子进程。
=====================
请问老师，这样是解决僵尸和孤儿进程的最佳方式吗？
作者回复: @po,
> 问题A: 如果init没有waitpid()或者wait()功能，那么僵尸进程是不是就不能回收了？
对的，如果父进程没有waitpid/wait, 那么僵尸进程就不能回收了。

> 问题B: 像在容器中，产生僵尸进程是应用的问题吧？容器平台并不能解决僵尸进程的问题，需要开发介入吧？
是的。

> 问题C
对的，可以在容器里启动dumb-init/tini之类的小型init服务来解决容器里init进程相关的问题。

8.
如果容器的 init 进程创建了子进程 B，B 又创建了自己的子进程 C。如果 C 运行完之后，退出成了僵尸进程，B 进程还在运行，而容器的 init 进程还在不断地调用 waitpid()，那 C 这个僵尸进程可以被回收吗？
不会，因为init的waitpid只会清理他的子进程，而B进程正常运行，没有僵尸。我理解的对吗？
老师，问一下，如果这时候我们将B杀死，C的僵尸就会变成孤儿僵尸，就会被init（1）托管，这种情况会被清理吗？
作者回复: @骑马户兜风
> 问一下，如果这时候我们将B杀死，C的僵尸就会变成孤儿僵尸，就会被init（1）托管，这种情况会被清理吗？

对的，这种情况C的父进程就会变为1 (init)。如果init里在waitpid()，那么就可以清理它了。



