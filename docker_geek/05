
三个重要的参数：

cpu.cfs_period_us 100000 它是 CFS 算法的一个调度周期，一般它的值是 100000，以 microseconds 为单位，也就 100ms
cpu.cfs_quota_us  -1  它“表示 CFS 算法中，在一个调度周期里这个控制组被允许的运行时间，比如这个值为 50000 时，就是 50ms
cpu.shares 占用cpu的比例

kubenetes的设置
Limit CPU 就是容器所在 Cgroup 控制组中的 CPU 上限值，Request CPU 的值就是控制组中的 cpu.shares 的值。


1.
请问下关于wa和hi/si的问题：
1. 例子中，wa是等待磁盘IO的状态，那等待网络IO时，是不是wa呢？
2. 例子中，hi/si是收到网卡中断，那收到磁盘中断时，是不是也是hi/si？
作者回复: 网络I/O 没有wa状态部分。
hi/si 对于磁盘都是有的。

2.
请问老师，我在环境上遇到 cpu.cfs_quota_us 取值为 -1 的，这种是不是代表的不限制CPU的使用 ？
作者回复: 对的，不限制。

3.
CPU的使用率在linux里面是树状结构，CPU的share是针对同等深度来做区分。由于三个shell命令都会把CPU占满。所以最后CPU的分配比例是：group1：4， group3：1， group4：3

4.
有个疑问：假设给容器配置了 1.5 的 CPU，而宿主机上只有 1 个 CPU，其实现在来说配置多少个 CPU 应该指的使用多少的 CPU 的时间对吗？（ 而非简单地分配物理 CPU ）
作者回复: 是的，这是一个调度时间的分配，而不是把物理cpu 分配给容器的进程。
对于你说的这种情况，就是不限制cpu的使用时间了。

5.
好，下面我们再来运行第二个例子来理解 cpu.shares。我们先把第一个例子里的程序启动，同时按前面的内容，一步步设置好 group3 里 cpu.cfs_quota_us 和 cpu.shares。

是不是写错了，
第一个例子的程序停止？
作者回复: 哦， 在这里的“程序”， 我指的是 ./threads-cpu/threads-cpu

6.
有一点不理解，想请教下老师：
而"Request CPU"就是无论其他容器申请多少 CPU 资源，即使运行时整个节点的 CPU 都被占满的情况下，我的这个容器还是可以保证获得需要的 CPU 数目，


假设系统只有2个group并列，group1和group2，系统总共2CPU
group1 ：request 2 cpu，limit 3 cpu
group2 ：request 2 cpu，limit 3 cpu

*****由于申请总量大于总量，那么按照K8S的调度原则，是没法启动全部容器的。上面的假设情况，按道理是不存在的，对吧。********
作者回复: 是的，上面的情况不存在。
假如第一个pod (group1)已经被调度上了，那么第二个pod(group2)是调度不到同一个node上的。

