1.
Momory Cgroup 应该包括了对内核内存的限制，老师给出的例子情况比较简单，基本没有使用 slab，可以试下在容器中打开海量小文件，内核内存 inode、dentry 等会被计算在内。

内存使用量计算公式（memory.kmem.usage_in_bytes 表示该 memcg 内核内存使用量）：
memory.usage_in_bytes = memory.stat[rss] + memory.stat[cache] + memory.kmem.usage_in_bytes

另外，Memory Cgroup OOM 不是真正依据内存使用量 memory.usage_in_bytes，而是依据 working set（使用量减去非活跃 file-backed 内存），working set 计算公式：
working_set = memory.usage_in_bytes - total_inactive_file
作者回复: @莫名， 很赞！每次你都可以更深入的挖掘知识点！

2.
您好，问一个操作系统相关的问题。根据我的理解，操作系统为了性能会在刷盘前将内容放在page cache中（如果可以申请的话），后续合适的时间刷盘。如果是这样的话，在一定条件下，可能还没刷盘，这个内存就需要释放给rss使用。这时必然就会先刷盘。这样会导致 系统 malloc 的停顿，对吗？如果是这样的话，另外一个问题就是 linux 是如何保证 磁盘的数据的 crash safe 的呢？
作者回复: 是的，在系统申请物理内存的时候，如果不够，会因为释放page cache而增加延时。
对于在page cache中的dirty page, 有kernel thread会根据dirty_* 相关的参数在在后台不断的写入磁盘。不过如果发生断电，那么在内存中还没有写入的dirty page还是丢失的。

3.
page_cache是不是会被很多进程共享呢，比如同一个文件需要被多个进程读写，这样的话，page_cache会不会无法被释放呢？

另外，老师能不能讲解下，这里面的page_cache和free中的cache、buffer、shared还有buffer cache的区别呢？
作者回复: 即使page cache对应的文件被多个进程打开，在需要memory的时候还是可以释放page cache的。进程打开的只是文件，page cache只是cache。

free里的cache/buffer就是page cache, 早期Linux文件相关的cache内存分buffer cache和page cache, 现在统一成page cache了。 shared内存一般是tmpfs 内存文件系统的用到的内存。

4.
老师，如果新程序申请的内存大小是大于之前进程的page cache内存大小的；是不是就会发生oom？
作者回复: 这个还要看之前page cache总共使用了多少。 如果新进程最后实际使用到的内存， 比如RSS， 和之前进程的RSS相加大于容器的内存限制，那么就会发生OOM.

5.
