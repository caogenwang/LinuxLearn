1. 僵尸进城
    进程终止，父进程尚未挥手，子进程残留资源PCB存放于内核中，编程僵尸进程。
    值得注意的是，僵尸进程不能使用kill()命令杀死，kill是终结一个进程的，而僵死进程是出现在进程终止后出现的；

    孤儿进程:
    父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init 进程领养孤儿进程。

2. 对多态的理解
    静态多态：发生在编译阶段，具体变现为函数重载，泛型编程。
    动态多态：发生在程序运行时，需要满足两个条件。具体为函数的重写。
    -1.虚函数，在派生类中对基类虚函数重写；
    -2.在继承体系中，通过基类类型的指针或引用来调用虚函数。

    动态多态是指通过基类的指针或者引用，在运行时动态调用实际绑定对象函数的行为。
    与之相对应的编译时绑定函数称为静态绑定。多态是面向对象编程的核心思想之一，
    因此我们有必要深入探索一下它的实现原理。动态绑定就是多态的本质。

    动态多态的实现就是通过虚函数
    构造函数，友元函数，静态函数不能声明为虚函数，赋值运算符重载不建议声明为虚函数
    https://blog.csdn.net/wei_cheng18/article/details/78236872
    https://blog.csdn.net/kwanson/article/details/80379360

3. set结构的应用场景

4. set按序插入自定义数据结构应该怎么设计？
    设计key，key的实现要通过hash函数，设计一个hash函数。另外还要操作符重载实现<和=符号。
    类似于map的实现要实现<号一样，需要定义如何排序。

5. TCP和UDP的应用场景
    区别

    面向连接VS无连接
    TCP建立一个连接需要3次握手IP数据包，断开连接需要4次握手。另外断开连接时发起方可能进入TIME_WAIT状态长达数分钟（视系统设置，windows一般为120秒），在此状态下连接（端口）无法被释放。
    UDP不需要建立连接，可以直接发起。

    可靠VS不可靠
    TCP利用握手、ACK和重传机制，udp没有。
        1，校验和（校验数据是否损坏）；
        2，定时器（分组丢失则重传）；
        3，序列号（用于检测丢失的分组和重复的分组）；
        4，确认应答ACK（接收方告知发送方正确接收分组以及期望的下一个分组）；
        5，否定确认（接收方通知发送方未被正确接收的分组）；
        6，窗口和流水线（用于增加信道的吞吐量）。（窗口大小：无需等待确认应答而可以继续发送数据的最大值）
    有序性
        TCP利用seq序列号对包进行排序，udp没有。
        面向字节流vs面向报文
        面向报文
        面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。（一个upd的最大报文长度2^16-1-20-8,20是ip报文头，8是udp报文头）
        面向字节流
        面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。
    
    tcp有流量控制，udp没有
    tcp的头部比20bytes，udp8byres
    TCP应用场景：
        效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。

    UDP应用场景：
        效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。

6. vector的底层数据结构，size和capacity的区别？
    vector可以看做是一个动态的数组，是一段连续的线性内存空间。
    capacity 一般大于size的原因是为了避免 每次增加数据时都要重新分配内存，所以一般会 生成一个较大的空间，以便随后的数据插入。
    size是当前vector容器真实占用的大小，也就是容器当前拥有多少个元素。
    capacity是指在发生realloc前能允许的最大元素数，即预分配的内存空间。
    这两个属性分别对应两个方法：resize()和reserve()。
    使用resize()，容器内的对象内存空间是真正存在的。
    使用reserve()仅仅只是修改了capacity的值，容器内的对象并没有真实的内存空间(空间是"野"的)。
    原文链接：https://blog.csdn.net/luolaihua2018/article/details/115300474

7. vector的删除函数是什么？删除的结果呢？
    earse函数。删除元素会导致迭代器的失效。

8. map的底层数据结构

9. 智能指针：

10. c++有哪些新特性？

11. move的作用
    返回传入参数的右值引用。右值引用的概念是在C++11才提出来的。在此之前只有一种引用。将一个左值
    强制转换成右值引用，继而我们可以通过右值引用使用该值。

12. c++拷贝构造的理解
    拷贝构造函数，是一种特殊的构造函数，它由编译器调用来完成一些基于同一类的其他对象的构建及初始化。
    其唯一的参数（对象的引用）是不可变的（const类型）。

    为什么拷贝构造参数是引用类型？
    其原因如下：当一个对象以传递值的方式传一个函数的时候，拷贝构造函数自动被调用来生成函数中的对象
    （符合拷贝构造函数调用的情况）。如果一个对象是被传入自己的拷贝构造函数，
    它的拷贝构造函数将会被调用来拷贝这个对象，这样复制才可以传入它自己的拷贝构造函数，
    这会导致无限循环直至栈溢出（Stack Overflow）。

    如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，
    该构造函数完成对象之间的位拷贝。（位拷贝又称浅拷贝，后面将进行说明。）自定义拷贝构造函数是一
    种良好的编程风格，它可以阻止编译器形成默认的拷贝构造函数，提高源码效率。

13. 虚函数的位置？
    虚函数在类的开始的位置的虚函数指针，指向一个虚函数的表，一开始的4个字节为0，再接下来4个字节是typeinfo信息。
    在接下来是虚函数的地址，依次是虚函数定义的先后顺序。

14. static在c中作用
    static修饰全局变量：在全局变量前加static，全局变量就被定义成为一个全局静态变量。
    


15. vector一次申请过大的内存会如何？
    系统内存不够用了 就从所需内存的右侧链表找 如果找的到 就直接将其一块小区块 注入 内存池中 再将其分配出去
    如果所有的右侧都没有了 那就回到一级适配器 给 new handler 处理 看看还有没有一些补救措施 释放掉一些内存给我们用
    如果还是不行 那就 凉 了
    最后应该是系统异常了。抛出bad_alloc的异常。

16. 进程的状态有哪些？
    进程的五种基本状态：
    创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。
             如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态
    就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行
    执行状态：进程处于就绪状态被调度后，进程进入执行状态
    阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。
             在满足请求时进入就绪状态等待系统调用
    终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行
    原文链接：https://blog.csdn.net/cafucwxy/article/details/78453430


    