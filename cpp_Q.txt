1. 在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？
    构造时先执行父类的构造函数，再执行子类的构造函数；析构是先调用子类的析构函数，再调用父类的析构函数
2. 在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？
    父类的析构函数需要声明为虚函数，构造函数不能声明为虚函数：如果构造函数是虚函数，则它需要通过类的虚表来调用，而虚表的指针保存在对象中，没有调用构造函数，就没有对象
    如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象，例如子类资源没有回收
3. 什么是 C++ 多态？C++ 多态的实现原理是什么？
    c++多态就是多态可以简单地理解为同一条函数调用语句能调用不同的函数；或者说，对不同对象发送同一消息，使得不同对象有各自不同的行为
    静态多态：c++的同名函数根据参数的类型和个数的不同编译成不同的函数，就是在编译期间就确定的调用关系
    动态多态：通过虚函数来实现，实现运行时绑定；通常是一个父类指针指向不同的子类，在运行时在确定调用具体子类的函数
4. 什么是虚函数？虚函数的实现原理是什么？
    虚函数:虚函数是指一个类中你希望重载的成员函数 ，当你用一个基类指针或引用指向一个继承类对象的时候，调用一个虚函数时, 实际调用的是继承类的版本
    虚函数的实现原理:虚函数是通过虚函数表来实现，每个具有虚函数的类都有一个指针指向虚函数表，表中存放的是类中的虚函数，当子类继承
                    基类的时候，如果有重写父类的虚函数，则对应的虚表位置会替换成对应子类的虚函数(存放的是对应函数的地址)，所以再基类指针或者引用在
                    指向子类时，当调用到对应的函数时，会直接调用子类重写的虚函数。
5. 什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？
    虚表是存放一个类的虚函数地址的一段内存空间,是一个指针数组
    虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了
    虚表的第一项是该类的第一个虚函数的地址

6. 菱形继承（类 D 同时继承 B 和 C，B 和 C又继承自A）体系下，虚表在各个类中的布局如何？
    如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？
    菱形继承的虚函数表:

7. 构造函数中是否可以调用虚函数？为什么？
    构造函数中最好不要调用虚函数，当在构造基类部分时，派生类还没被完全创建，从某种意义上讲此时它只是个基类对象。
    即当Base::Base()执行时Derive对象还没被完全创建，此时它被当成一个Base对象，
    而不是Derive对象，因此Foo绑定的是Base的Foo，达不到想要的结果。

8. 智能指针有用过吗？介绍一下三种智能指针的区别？
    unique_ptr：是指针指针独享资源，
    shared_ptr是通过计数的方式实现资源的共享
    weak_ptr：是配合shared_ptr的使用，不会增加资源的引用计数，可以消除shared_ptr循环引用造成的资源无法释放

9. 线程同步的机制有哪些？哪种方式的效率高一些？
    互斥锁，读写锁，信号量，条件变量，原子操作
    原子操作高一些，其次是读写锁。再其次是一些互斥锁和信号量

另外，时至今日，你一定要熟悉 C++11/14/17 常用的语言特性和类库，这里简单地列一下：
统一的类成员初始化语法与 std::initializer_list
注解标签（attributes）
final/override/=default/=delete 语法
auto 关键字
Range-based 循环语法
结构化绑定
stl 容器新增的实用方法
std::thread
线程局部存储 thread_local
线程同步原语 std::mutex、std::condition_variable 等
原子操作类
智能指针类
std::bind/std::function               