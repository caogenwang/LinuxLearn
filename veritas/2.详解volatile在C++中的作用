volatile的介绍
      volatile类似于大家所熟知的const也是一个类型修饰符。volatile是给编译器的指示来说明对它所修饰的对象不应该执行
      优化。volatile的作用就是用来进行多线程编程。在单线程中那就是只能起到限制编译器优化的作用。所以单线程的童鞋们就不用浪费精力看下面的了。

没有volatile的结果
      如果没有volatile，你将无法在多线程中并行使用到基本变量。下面举一个我开发项目的实例（这个实例采用的是C#
      语言但不妨碍我们讨论C++）。在学校的一个.Net项目的开发中，我曾经在多线程监控中用到过一个基本变量Int32型的，
      我用它来控制多线程中监控的一个条件。考虑到基本变量是编译器自带的而且无法用lock锁上，我想当然的以为是原子操作不会有多线程的问题，可实际运行后发现程序的运行有时正常有时异常，改为用Dictionary对象处理并加锁以后才彻底正常。现在想来应该是多线程同时操作该变量了，具体的将在下面说清。
volatile的作用
      如果一个基本变量被volatile修饰，编译器将不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置上。
      这一点就避免了没有volatile修饰的变量在多线程的读写中所产生的由于编译器优化所导致的灾难性问题。所以多线程中必须要
      共享的基本变量一定要加上volatile修饰符。当然了，volatile还能让你在编译时期捕捉到非线程安全的代码。我在下面还会介
      绍一位大牛使用智能指针来顺序化共享区代码的方法，在此对其表示感谢。
      泛型编程中曾经说过编写异常安全的代码是很困难的，可是相比起多线程编程的困难来说这就太小儿科了。多线程编程中你需要
      证明它正确，需要去反复地枯燥地调试并修复，当然了，资源竞争也是必须注意的，最可恨的是，有时候编译器也会给你点颜色看
      看。。。
class Student { 
    public: 
    void Wait() //在北航排队等吃饭实在是很痛苦的事情。。。 
    {
        while(!flag)
        { 
            Sleep(1000); // sleeps for 1000 milliseconds 
        } 
    } 
    void eat() { 
        flag = true; 
        } 
        ... 
    private: 
    bool flag; 
};

  好吧，多线程中你就等着吃饭吧，可在这个地方估计你是永远等不到了，因为flag被编译器放到寄存器中去了，
  哪怕在你前面的那位童鞋告诉你flag=true了，可你就好像瞎了眼看不到这些了。这么诡异的情况的发生时因为你所用到的判断
  值是之前保存到寄存器中的，这样原来的地址上的flag值更改了你也没有获取。该怎么办呢？对了，改成volatile就解决了。

  volatile对基本类型和对用户自定义类型的使用与const有区别，比如你可以把基本类型的non-volatile赋值给volatile，
  但不能把用户自定义类型的non-volatile赋值给volatile，而const都是可以的。还有一个区别就是编译器自动合成的复制控制
  不适用于volatile对象，因为合成的复制控制成员接收const形参，而这些形参又是对类类型的const引用，但是不能将volatile
  对象传递给普通引用或const引用。

volatile成员函数
    关于类的话，首先如果类是volatile则里面的成员都是volatile的。其次要将成员函数声明为volatile则同
    const一样在函数最后声明即可。当你设计一个类的时候，你声明的那些volatile成员函数是线程安全的，所以那些随时可能被调用的函数应该声明为volatile。考虑到volatile等于线程安全代码和非临界区；non-volatile等于单线程场景和在临界区之中。我们可以利用这个做一个函数的volatile的重载来在线程安全和速度优先中做一个取舍。具体的实现此处就略去了。

总结
    在编写多线程程序中使用volatile的关键四点：

    1.将所有的共享对象声明为volatile；